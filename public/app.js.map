{"version":3,"sources":["app/zoom.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5iBA;AAAA","file":"public/app.js","sourcesContent":["/**\n * @author Jeremie Ges <jges@weblinc.com>\n */\n\n(function($) {\n    function Zoom() {\n\n        this.$dom = {\n            container: null,\n            image: null,\n            thumbnail: null\n        },\n\n        /**\n         * Keep track of things\n         * @type {Object}\n         */\n        this.flags = {\n\n            /**\n             * The current scale\n             * @type {Number}\n             */\n            currentScale: 1,\n\n            /**\n             * Check if we already tried to load\n             * the zoom image\n             * @type {Boolean}\n             */\n            imageIntentLoading: false,\n\n            /**\n             * Check if the zoom image is loaded\n             * @type {Boolean}\n             */\n            imageLoaded: false,\n\n            /**\n             * We use \"transform: translate()\" to \"move\" the\n             * zoom image (for smooth animations). When X or Y\n             * change, we update this property.\n             * @type {Object}\n             */\n            imageTranslate: {\n                x: 0,\n                y: 0\n            },\n\n            /**\n             * [pinchCoordinates description]\n             * @type {Object}\n             */\n            pinchCoordinates: {\n                x: 0,\n                y: 0\n            },\n            pinchScale: 0\n        },\n\n        this.options = {},\n\n        this.init = function(container, options) {\n            this.$dom.container = $(container);\n            this.options = _.extend($.fn.zoom.defaults, options);\n            this.setup();\n            this.events();\n        },\n\n        this.setup = function() {\n            this.setupImage();\n            this.setupThumbnail();\n        },\n\n        this.setupImage = function() {\n            this.$dom.image = $('<img/>');\n        },\n\n        this.setupThumbnail = function() {\n            this.$dom.thumbnail = this.$dom.container.find('img').first();\n        },\n\n        this.events = function() {\n            this.$dom.image.on('load', this.onLoadImage.bind(this));\n\n            this.getInstanceHammer(this.$dom.container.get(0))\n                .on('doubletap', this.onDoubleTapContainer.bind(this))\n                .on('pan',  this.onPanContainer.bind(this))\n                .on('panright', this.onPanRightContainer.bind(this))\n                .on('panleft', this.onPanLeftContainer.bind(this))\n                .on('pandown', this.onPanDownContainer.bind(this))\n                .on('panup', this.onPanUpContainer.bind(this))\n                .on('pinchstart', this.onPinchStartContainer.bind(this))\n                .on('pinch', this.onPinchContainer.bind(this));\n        },\n\n        this.onLoadImage = function() {\n            // Insert zoom image in page\n            this.$dom.image\n                .css({\n                    opacity: 1,\n                    position: 'absolute',\n                    top: 0,\n                    left: 0,\n                    width: this.$dom.container.width(),\n                    height: this.$dom.container.outerHeight(),\n                    border: 'none',\n                    maxWidth: 'none',\n                    maxHeight: 'none',\n                    transformOrigin: '0 0',\n                    transform: 'translate(0px, 0px) scale(1)',\n                    transition: 'all 1s'\n                })\n                .attr('role', 'presentation')\n                .appendTo(this.$dom.container);\n\n            this.$dom.container.css('overflow', 'hidden');\n            this.flags.imageLoaded = true;\n\n            this.getScaleLimitImage();\n        },\n\n        /**\n         * When the user start to pan the container\n         */\n        this.onPanContainer = function(e) {\n            e.preventDefault();\n            this.loadImage();\n        },\n\n        /**\n         * When the user starts to pinch the container\n         * we want to keep track of the point clicked\n         * (coordinates) to scale up / down gracefully.\n         * @param  {Event} e The pinch event\n         */\n        this.onPinchStartContainer = function(e) {\n            e.preventDefault();\n            this.loadImage();\n            this.flags.pinchCoordinates = e.center;\n        },\n\n        /**\n         * Guess if we have to scale up / down\n         * the zoom image on pinch\n         * @param  {Event} e The pinch event\n         */\n        this.onPinchContainer = function(e) {\n            var scale;\n\n            e.preventDefault();\n\n            scale = e.scale;\n\n            if (scale < this.flags.pinchScale) {\n                this.onScaleDown();\n            } else {\n                this.onScaleUp();\n            }\n\n            this.flags.pinchScale = scale;\n        },\n\n        /**\n         * Scale down the zoom image around the point\n         * clicked by the user at the start of the pinch\n         */\n        this.onScaleDown = function() {\n            var scale = this.flags.currentScale,\n                containerOffset = this.$dom.container.offset(),\n                mousePositionOnImageX,\n                mousePositionOnImageY,\n                offsetX,\n                offsetY,\n                x,\n                y;\n\n            if (scale <= 1) {\n                return;\n            }\n\n            scale = scale - this.options.deltas.scale;\n\n            mousePositionOnImageX = this.flags.pinchCoordinates.x - containerOffset.left;\n            mousePositionOnImageY = this.flags.pinchCoordinates.y - containerOffset.top;\n\n            /**\n             * Objective\n             * take offsetX and offsetY down to 0 at the same rate that scale goes down to 1.\n             */\n\n\n            offsetX = mousePositionOnImageX * this.options.deltas.scale;\n            offsetY = mousePositionOnImageY * this.options.deltas.scale;\n            // debugger;\n\n            x = this.flags.imageTranslate.x < 0 ? this.flags.imageTranslate.x : 0;\n            y = this.flags.imageTranslate.y < 0 ? this.flags.imageTranslate.y : 0;\n\n            // offsetX = offsetX < ('full width of image') - this.$dom.container.width() ? offsetX + x : offsetX * scale;\n            offsetX = offsetX + x;\n            offsetY = offsetY + y;\n\n            this.$dom.image.css({\n                //width: this.$dom.container.width() * scale,\n                //height: this.$dom.container.outerHeight() * scale,\n                transform: this.getCssRuleTranslate(offsetX, offsetY) + ' ' + this.getCssRuleScale(scale)\n            });\n\n            // Keep track of things\n            this.flags.imageTranslate.x = offsetX;\n            this.flags.imageTranslate.y = offsetY;\n            this.flags.currentScale = scale;\n\n        },\n\n        /**\n         * Scale up the zoom image around the point\n         * clicked by the user at the start of the pinch\n         */\n        this.onScaleUp = function() {\n            var scale = this.flags.currentScale + this.options.deltas.scale,\n                containerOffset = this.$dom.container.offset(),\n                offsetX,\n                offsetY,\n                mousePositionOnImageX,\n                mousePositionOnImageY,\n                transform;\n\n            if (scale > this.getScaleLimitImage()) {\n                return;\n            }\n\n            mousePositionOnImageX = (this.flags.pinchCoordinates.x - containerOffset.left);\n            mousePositionOnImageY = (this.flags.pinchCoordinates.y - containerOffset.top);\n\n            offsetX = -(mousePositionOnImageX * this.options.deltas.scale);\n            offsetY = -(mousePositionOnImageY * this.options.deltas.scale);\n\n            offsetX = offsetX < 0 ? offsetX + this.flags.imageTranslate.x : 0;\n            offsetY = offsetY < 0 ? offsetY + this.flags.imageTranslate.y : 0;\n\n            this.$dom.image.css({\n                //width: this.$dom.thumbnail.width() * scale,\n                //height: this.$dom.container.outerHeight() * scale,\n                transform: this.getCssRuleTranslate(offsetX, offsetY) + ' ' + this.getCssRuleScale(scale)\n            });\n\n            this.flags.imageTranslate.x = offsetX;\n            this.flags.imageTranslate.y = offsetY;\n            this.flags.currentScale = scale;\n        },\n\n        /**\n         * When the user double tap on the container,\n         * depending the current scale we zoom the image\n         * to its maximum or minimum\n         */\n        this.onDoubleTapContainer = function(e) {\n            console.log('double tap');\n            var coordinates = e.center;\n\n            console.log(coordinates);\n\n            e.preventDefault();\n\n            this.loadImage();\n\n            if (this.flags.currentScale === 1) {\n                this.zoomMaximum(coordinates);\n            } else {\n                this.zoomMinimum();\n            }\n        },\n\n        /**\n         * When the user pan up, move\n         * the picture on the bottom\n         */\n        this.onPanUpContainer = function() {\n\n            var x = this.flags.imageTranslate.x,\n                y = this.flags.imageTranslate.y,\n                newY = y - this.options.deltas.pan;\n\n            if (newY < this.getPanLimits().y) {\n                return;\n            }\n\n            this.$dom.image.css({\n                transform: this.getCssRuleTranslate(x, newY) + ' ' + this.getCssRuleScale(this.flags.currentScale)\n            });\n\n            this.flags.imageTranslate.y = newY;\n        },\n\n        /**\n         * When the user pan down, move\n         * the picture on the top\n         */\n        this.onPanDownContainer = function() {\n            console.log('on pan down');\n            var x = this.flags.imageTranslate.x,\n                y = this.flags.imageTranslate.y;\n                newY = y + this.options.deltas.pan;\n\n            console.log(x);\n            console.log(y);\n\n            if (newY > 0) {\n                return;\n            }\n\n            this.$dom.image.css({\n                transform: this.getCssRuleTranslate(x, newY) + ' ' + this.getCssRuleScale(this.flags.currentScale)\n            });\n\n            this.flags.imageTranslate.y = newY;\n        },\n\n        /**\n         * When the user pan right, move\n         * the picture on the left\n         */\n        this.onPanRightContainer = function() {\n            var y = this.flags.imageTranslate.y,\n                x = this.flags.imageTranslate.x,\n                newX = x + this.options.deltas.pan;\n\n            if (newX > 0) {\n                return;\n            }\n\n            this.$dom.image.css({\n                transform: this.getCssRuleTranslate(newX, y) + ' ' + this.getCssRuleScale(this.flags.currentScale)\n            });\n\n            this.flags.imageTranslate.x = newX;\n        },\n\n        /**\n         * When the user pan left, move\n         * the picture on the right\n         */\n        this.onPanLeftContainer =  function() {\n            var y = this.flags.imageTranslate.y,\n                x = this.flags.imageTranslate.x,\n                newX = x - this.options.deltas.pan;\n\n            if (newX < this.getPanLimits().x) {\n                return;\n            }\n\n            this.$dom.image.css({\n                transform: this.getCssRuleTranslate(newX, y) + ' ' + this.getCssRuleScale(this.flags.currentScale)\n            });\n\n            this.flags.imageTranslate.x = newX;\n        },\n\n        /**\n         * Will scale up to the maximum scale allowed taking in account\n         * the focal point clicked by the user.\n         * @param  {Object} coordinates - X / Y of the point clicked\n         */\n        this.zoomMaximum = function(coordinates) {\n            var maximumScale = this.getScaleLimitImage(),\n                containerOffset = this.$dom.container.offset(),\n                mousePositionOnImageX = (coordinates.x - containerOffset.left),\n                mousePositionOnImageY = (coordinates.y - containerOffset.top),\n                offsetX = -(mousePositionOnImageX * (maximumScale - this.flags.currentScale)),\n                offsetY = -(mousePositionOnImageY * (maximumScale - this.flags.currentScale));\n                //offsetX = -(mousePositionOnImageX),\n                //offsetY = -(mousePositionOnImageY);\n\n            if (offsetY > 0) {\n                offsetY = 0;\n            }\n            console.log('mousePositionOnImage', mousePositionOnImageX, mousePositionOnImageY);\n            console.log('offset', offsetX, offsetY);\n\n            this.$dom.image.css({\n                //width: this.$dom.container.width() * maximumScale,\n                //height: this.$dom.container.outerHeight() * maximumScale,\n                transform: this.getCssRuleTranslate(offsetX, offsetY) + ' ' + this.getCssRuleScale(maximumScale)\n            });\n\n            this.flags.imageTranslate.x = offsetX;\n            this.flags.imageTranslate.y = offsetY;\n            this.flags.currentScale = maximumScale;\n        },\n\n        /**\n         * Will scale down to scale 1\n         */\n        this.zoomMinimum = function() {\n            var minimumScale = 1;\n\n            this.$dom.image.css({\n                //width: this.$dom.container.width() * minimumScale,\n                //height: this.$dom.container.outerHeight() * minimumScale,\n                top: 0,\n                left: 0,\n                transform: 'translate(0, 0) scale(1)'\n            });\n\n            this.flags.imageTranslate.x = 0;\n            this.flags.imageTranslate.y = 0;\n            this.flags.currentScale = minimumScale;\n        },\n\n        /**\n         * Show the zoom image\n         */\n        this.showImage = function() {\n            this.$dom.image.css('opacity', 1);\n        },\n\n        /**\n         * Hide the zoom image\n         */\n        this.hideImage = function() {\n            this.$dom.image.css('opacity', 0);\n        },\n\n        /**\n         * Lazy load the image on demand.\n         */\n        this.loadImage = function() {\n            if (this.flags.imageLoaded) {\n                return;\n            }\n\n            if (this.flags.imageIntentLoading) {\n                return;\n            }\n\n            this.$dom.image.attr('src', this.getUrlImage());\n            this.flags.imageIntentLoading = true;\n        },\n\n        /**\n         * Get the url of the zoom image to use.\n         * @return {String} Url (relative or absolute)\n         */\n        this.getUrlImage = function() {\n            return this.$dom.container.data('zoom-src');\n        },\n\n        /**\n         * When the zoom image is scaling up, we need to know\n         * the limit of scaling to keep the perfect quality ratio.\n         * @return {Float} The scale up limit\n         */\n        this.getScaleLimitImage = function() {\n            var image = this.getNaturalDimensionsImage(),\n                scaleWidth,\n                scaleHeight,\n                limit;\n\n            scaleWidth = image.width / this.$dom.container.width();\n            scaleHeight = image.height / this.$dom.container.outerHeight();\n\n            limit = _.min([scaleWidth, scaleHeight]);\n\n            return _.round(limit, 2);\n        },\n\n        /**\n         * When the zoom image is panning (up / down / left / right),\n         * we need to know what are the limits for X and Y to avoid\n         * to pan outside of the container.\n         * @return {Object} The X / Y limits\n         */\n        this.getPanLimits = function() {\n            var xLimit = (this.$dom.image.width() * this.flags.currentScale) - this.$dom.container.width(),\n                yLimit = (this.$dom.image.height() * this.flags.currentScale) - this.$dom.container.outerHeight();\n\n            return {\n                x: -xLimit,\n                y: -yLimit\n            }\n        },\n\n        /**\n         * Get the real width / height of the thumbnail\n         * @return {Object} The width / height\n         */\n        this.getNaturalDimensionsThumbnail = function() {\n            return {\n                width: this.$dom.thumbnail.prop('naturalWidth'),\n                height: this.$dom.thumbnail.prop('natureHeight')\n            }\n        },\n\n        /**\n         * Get the real width / height of the zoom image\n         * @return {Object} The widht / height\n         */\n        this.getNaturalDimensionsImage = function() {\n            return {\n                width: this.$dom.image.prop('naturalWidth'),\n                height: this.$dom.image.prop('naturalHeight')\n            }\n        },\n\n        this.getCssRuleTranslate = function(x, y) {\n            return 'translate(' + x + 'px,' + y + 'px)';\n        },\n\n        this.getCssRuleScale = function(scale) {\n            return 'scale(' + scale + ')';\n        },\n\n        /**\n         * Create an hammer instance for the\n         * element given with the right recognizers:\n         * Double Tap / Pinch / Pan\n         * @param {HTMLelement} element - Initialize the events to this element\n         *\n         * @example\n         * var element = document.getElementById('element');\n         * this.getInstanceHammer(element);\n         */\n        this.getInstanceHammer = function(element) {\n            var manager = new Hammer.Manager(element),\n                doubleTap = new Hammer.Tap({event: 'doubletap', taps: 2}),\n                pinch = new Hammer.Pinch(),\n                pan = new Hammer.Pan({threshold: 1});\n\n            manager.add([doubleTap, pinch, pan]);\n\n            return manager;\n        }\n    }\n\n    /**\n     * Public jQuery API\n     */\n\n    $.fn.zoom = function(options) {\n\n        var options = options || {};\n\n        return this.each(function() {\n            new Zoom().init(this, options);\n        });\n    };\n\n    $.fn.zoom.defaults = {\n        deltas: {\n            pan: 10,\n            scale: 0.04\n        }\n    };\n\n}(window.jQuery));"]}